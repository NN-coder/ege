# ----------------------------------------------------------------------------------------------------
# Исполнитель преобразует число на экране. У исполнителя есть две команды, которым присвоены номера. Первая команда 
# увеличивает число на экране на 1, вторая умножает его на 2. Программа для исполнителя – это последовательность 
# команд. Сколько существует программ, для которых при исходном числе 1 результатом является число 20, и при этом 
# траектория вычислений содержит число 10?
# ----------------------------------------------------------------------------------------------------
def numProg(start, x):
  if x < start:              # Прописывать всегда
    return 0                 # Прописывать всегда
  if x == start:             # Прописывать всегда
    return 1                 # Прописывать всегда
  k = numProg(start, x - 1)  # Прописывать всегда

  # Вторая команда умножает на 2, поэтому
  if x % 2 == 0:
    k += numProg(start, x // 2)

  return k                   # Прописывать всегда

# 1 - исходное число, 10 - число, которое должна содержать траектория, 20 - конечное число,
print(numProg(1, 10) * numProg(10, 20))

# ----------------------------------------------------------------------------------------------------
# Исполнитель М17 преобразует число на экране. У исполнителя есть три команды, которым присвоены номера. Первая команда 
# увеличивает число на экране на 1, вторая – увеличивает его на 2, а третья –  умножает его на 3. Программа для 
# исполнителя М17 – это последовательность команд. Сколько существует программ, для которых при исходном числе 2 
# результатом является число 12 и при этом траектория вычислений содержит числа 8 и 10?
# ----------------------------------------------------------------------------------------------------
def numProg(start, x):
  if x < start:              # Прописывать всегда
    return 0                 # Прописывать всегда
  if x == start:             # Прописывать всегда
    return 1                 # Прописывать всегда
  k = numProg(start, x - 1)  # Прописывать всегда

  # Вторая команда увеличивает на 2, поэтому
  if x - 2 > 0:
    k += numProg(start, x - 2)
  # Третья команда умножает на 3, поэтому
  if x % 3 == 0:
    k += numProg(start, x // 3)

  return k                   # Прописывать всегда

# 2 - начальное число, 8 и 10 - числа, которые должна содержать траектория, 12 - конечное число
print(numProg(2, 8) * numProg(8, 10) * numProg(10, 12))

# ----------------------------------------------------------------------------------------------------
# Исполнитель Июнь15 преобразует число на экране. У исполнителя есть две команды, которым присвоены номера. Первая 
# команда увеличивает число на экране на 1, вторая умножает его на 2. Программа для исполнителя Июнь15 – это 
# последовательность команд. Сколько существует программ, для которых при исходном числе 2 результатом является 
# число 29 и при этом траектория вычислений содержит число 14 и не содержит числа 25?
# ----------------------------------------------------------------------------------------------------
def numProg(start, x):
  if x < start:              # Прописывать всегда
    return 0                 # Прописывать всегда
  if x == start:             # Прописывать всегда
    return 1                 # Прописывать всегда
  k = numProg(start, x - 1)  # Прописывать всегда

  # Вторая команда умножает на 2, поэтому
  if x % 2 == 0:
    k += numProg(start, x // 2)

  return k                   # Прописывать всегда

# 2 - начальное число, 14 - число, которое должна содержать траектория, 25 пропускаем, потому что его не должно 
# быть в траектории, 29 - конечное число
print(numProg(2, 14) * numProg(14, 24) * numProg(26, 29))

# ----------------------------------------------------------------------------------------------------
# У исполнителя Удвоитель две команды, которым присвоены номера. Первая команда увеличивает число на экране на 1, 
# вторая умножает его на 2. Программа для исполнителя Удвоитель  – это последовательность команд. Сколько 
# существует программ, преобразующих число 4 в число 24, предпоследней командой которых является команда "1"?
# ----------------------------------------------------------------------------------------------------
def numProg(start, x):
  if x < start:              # Прописывать всегда
    return 0                 # Прописывать всегда
  if x == start:             # Прописывать всегда
    return 1                 # Прописывать всегда
  k = numProg(start, x - 1)  # Прописывать всегда

  # Вторая команда умножает на 2, поэтому
  if x % 2 == 0:
    k += numProg(start, x // 2)

  return k                   # Прописывать всегда

# Конечное число - 24, предпоследняя команда - 1, так что последняя команда может быть либо 1, либо 2, поэтому находим 
# количество программ до (24 - 1 - 1) и количество программ до (24 / 2 - 1), потом складываем
print(numProg(4, 22) + numProg(4, 11))

# ----------------------------------------------------------------------------------------------------
# Исполнитель Калькулятор преобразует число, записанное на экране. У исполнителя три команды, которым присвоены номера. 
# Первая из них увеличивает число на экране на 1, вторая увеличивает это число на 2, а третья прибавляет к числу на 
# экране число, большее на 1 (к числу 3 прибавляется 4, к числу 9 прибавляется 10 и т. д.). Программа для исполнителя 
# Калькулятор – это последовательность команд. Сколько есть программ, которые число 2 преобразуют в число 10?
# ----------------------------------------------------------------------------------------------------
def numProg(start, x):
  if x < start:              # Прописывать всегда
    return 0                 # Прописывать всегда
  if x == start:             # Прописывать всегда
    return 1                 # Прописывать всегда
  k = numProg(start, x - 1)  # Прописывать всегда

  # Вторая команда увеличивает число на 2, поэтому
  if x - 2 > 0:
    k += numProg(start, x - 2)
  # Третья команда прибавляет к числу следующее, и таким образом возможно получить только нечётное число, поэтому
  if x % 2 != 0:
    k += numProg(start, x // 2)

  return k                   # Прописывать всегда

print(numProg(2, 10))

# ----------------------------------------------------------------------------------------------------
# У исполнителя Калькулятор две команды, которым присвоены номера. Первая из них увеличивает число на экране на 1, 
# вторая – увеличивает на 1 число десятков. Если перед выполнением команды 2 вторая с конца цифра равна 9, она не 
# изменяется. Программа для Калькулятора – это последовательность команд. Сколько есть программ, которые число 15 
# преобразуют в число 28?
# ----------------------------------------------------------------------------------------------------
def numProg(start, x):
  if x < start:              # Прописывать всегда
    return 0                 # Прописывать всегда
  if x == start:             # Прописывать всегда
    return 1                 # Прописывать всегда
  k = numProg(start, x - 1)  # Прописывать всегда

  # Вторая команда увеличивает на 1 число десятков, то есть прибавляет 10, поэтому
  if x >= 10:
    k += numProg(start, x - 10)

  return k                   # Прописывать всегда

print(numProg(15, 28))

# ----------------------------------------------------------------------------------------------------
# У исполнителя Калькулятор две команды, которым присвоены номера. Первая из них увеличивает число на экране на 1, 
# вторая – увеличивает на 1 число десятков и число единиц. Если перед выполнением команды 2 какая-либо из двух 
# младших цифр равна 9, она не изменяется. Программа для Калькулятора – это последовательность команд. Сколько 
# есть программ, которые число 23 преобразуют в число 48?
# ----------------------------------------------------------------------------------------------------
def numProg(start, x):
  if x < start:              # Прописывать всегда
    return 0                 # Прописывать всегда
  if x == start:             # Прописывать всегда
    return 1                 # Прописывать всегда
  k = numProg(start, x - 1)  # Прописывать всегда

  # Вторая команда увеличивает на 1 число десятков и число единиц, то есть прибавляет 11, поэтому
  if x >= 10:
    k += numProg(start, x - 11)

  return k                   # Прописывать всегда

print(numProg(23, 48))
